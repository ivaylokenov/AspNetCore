@using Microsoft.AspNetCore.Components.RenderTree
<div class="node">
    <strong class="label">@Data.Label</strong>
    &nbsp;&nbsp;[
    Instance: @instanceId;

    Is new:
    @if (firstCreatedOnUpdateCount == RenderContext.UpdateCount)
    {
        <strong class="is-new">true</strong>
    }
    else
    {
        <span class="is-new">false</span>
    }
    ]

    @if (Data.Children?.Any() ?? false)
    {
        <div class="children">
            @((RenderFragment)RenderKeyCasesTreeNodes)
        </div>
    }
</div>

@code {
    public class Node
    {
        public string Key { get; set; }
        public string Label { get; set; }
        public List<Node> Children { get; set; }
    }

    string instanceId = Guid.NewGuid().ToString("D").Substring(0, 6);
    int firstCreatedOnUpdateCount;

    [Parameter] Node Data { get; set; }
    [CascadingParameter] KeyCasesComponent.RenderContext RenderContext { get; set; }

    protected override void OnInitialized()
    {
        firstCreatedOnUpdateCount = RenderContext.UpdateCount;
    }

    void RenderKeyCasesTreeNodes(RenderTreeBuilder builder)
    {
        // This is equivalent to:
        // @foreach (var child in Data.Children)
        // {
        //     if (key != null)
        //     {
        //        <KeyCasesTreeNode @key="@child.Key" @key:loose="@looseKey" Data="@child" />
        //     }
        //     else
        //     {
        //        <KeyCasesTreeNode Data="@child" />
        //     }
        // }
        // TODO: Once the compiler supports @key:loose, eliminate this and just use regular Razor syntax
        foreach (var child in Data.Children)
        {
            builder.OpenComponent<KeyCasesTreeNode>(0);
            if (child.Key != null)
            {
                builder.SetKey(child.Key, looseKey: RenderContext.UseLooseKeys);
            }
            builder.AddAttribute(1, nameof(Data), child);
            builder.CloseComponent();
        }
    }
}
